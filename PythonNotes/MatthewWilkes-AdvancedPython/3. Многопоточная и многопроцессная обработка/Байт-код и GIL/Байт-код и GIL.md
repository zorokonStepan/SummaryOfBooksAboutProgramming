### БАЙТ-КОД
```
        Чтобы понять пределы многопоточности в Python, нам придется заглянуть за кулисы и разобраться в том, как 
    интерпретатор загружает и выполняет код.
    
        Сам байт-код является деталью реализации и хранится в файлах с расширением .pyc. Он представляет поведение 
    программы на самом низком уровне. Интерпретация такого сложного языка, как Python, – нетривиальная задача, поэтому 
    интерпретатор кеширует результат в виде последовательности простых операций.
```

```
        Функция dis.dis(func) выводит байт-код заданной функции в предположении, что она написана на Python, а не 
    является C-расширением. Например, функция sorted(...) написана на C, поэтому байт-кода у нее нет.
```

```
        Для демонстрации рассмотрим функцию и результат ее дизассемблирования, полученный с помощью вызова 
    dis.dis(increment). Дизассемблер показывает номер строки в исходном файле, смещение байт-кода команды от начала 
    функции, имя команды и ее параметры – значения и в скобках соответствующие переменные или константы в Python-коде.
    
    Простая функция, увеличивающая глобальную переменную на 1
    
        num = 0
        def increment():
            global num
            num += 1 # 5 0 LOAD_GLOBAL 0 (num)
            
            
                # 2 LOAD_CONST    1 (1)
                # 4 INPLACE_ADD
                # 6 STORE_GLOBAL  0 (num)
    return None # 10 8 LOAD_CONST 0 (None)
                # 10 RETURN_VALUE
                
        Строка num += 1 выглядит как атомарная операция1, но байт-код показывает, что для ее выполнения интерпретатору 
    нужно четыре операции. Нам все равно, что это за операции, важно лишь, что нельзя доверять интуиции в вопросе о том, 
    какие операции атомарны, а какие – нет.
    
        Если бы мы выполнили эту функцию 100 раз, то в переменной num оказалось бы значение 100, что вполне логично. 
    Но если бы эта функция выполнялась в двух потоках, то нет никакой гарантии, что результат был бы равен 100. 
    Правильный результат получился бы, только если второй поток ни разу не выполнил команду байт-кода LOAD_GLOBAL в то 
    время, как первый был занят командами LOAD_CONST, IN_PLACE_ADD или STORE_GLOBAL. Python этого не гарантирует, 
    поэтому показанный код не является потокобезопасным.
```

### GIL
```
        В CPython имеется так называемая глобальная блокировка интерпретатора (Global Interpreter Lock – GIL), 
    призванная упростить обеспечение потокобезопасности.
    
        Эта блокировка означает, что в каждый момент времени исполнять Python-код может только один поток. Однако этого 
    недостаточно для решения нашей проблемы, потому что уровень гранулярности GIL – команда байт-кода, а это значит, что 
    хотя никакие две команды не могут выполняться одновременно, интерпретатор все равно может переключаться между путями 
    выполнения, что приводит к перекрытию. 
    
        Утверждение о том, что никакие две команды байт-кода не могут исполняться одновременно, не совсем верно.
    Команды байт-кода гораздо проще предложений Python, что позволяет интерпретатору делать заключения о том, какие 
    действия он выполняет в данный момент. Поэтому он может позволить нескольким потокам работать, если это безопасно, 
    например во время установления сетевого подключения или ожидания чтения данных из файла.
    
        Точнее, не все, что делает интерпретатор Python, требует захвата GIL. 
        
        Можно захватить GIL на все время от начала до конца исполнения команды байт-кода, но можно и освобождать в 
    промежутке. Ожидание появления данных в сокете – одна из вещей, которые можно делать, не захватывая GIL. Если 
    во время выполнения команды происходит операция ввода-вывода, то GIL можно освободить, и тогда интерпретатор может 
    одновременно выполнять любой код, не требующий захвата GIL, при условии что он находится в другом потоке. После того 
    как операция ввода-вывода завершится, поток должен ждать, когда сможет снова захватить GIL, удерживаемый другим 
    потоком, после чего может возобновить выполнение.    
    
        В ситуациях, когда код никогда не должен ждать завершения операции ввода-вывода, Python прерывает потоки через 
    некоторые промежутки времени, чтобы планирование потоков было справедливым.
    
        По умолчанию это происходит раз приблизительно в 0.005 секунды – достаточно долго, чтобы на моем компьютере наш 
    пример работал, как ожидается. Но если бы мы попросили интерпретатор переключать потоки чаще, вызвав функцию 
    sys.setswitchinterval(...), то начались бы ошибки.
    
    
    if __name__ == "__main__":
        import concurrent.futures
        import sys
        
        
        for si in [0.005, 0.0000005, 0.0000000005]:
            sys.setswitchinterval(si)
            results = []
            
            for attempt in range(100):
                with concurrent.futures.ThreadPoolExecutor(max_workers=2) as pool:
                    for i in range(100):
                        pool.submit(increment)
                
                results.append(num)
                num = 0
                
            correct = [a for a in results if a == 100]
            pct = len(correct) / len(results)
            print(f"{pct:.1%} правильно при sys.setswitchinterval({si:.10f})")
            
    На моем компьютере при прогоне этой программы было напечатано
    100.0% правильно при sys.setswitchinterval(0.0050000000)
    71.0% правильно при sys.setswitchinterval(0.0000005000)
    84.0% правильно при sys.setswitchinterval(0.0000000005)
```