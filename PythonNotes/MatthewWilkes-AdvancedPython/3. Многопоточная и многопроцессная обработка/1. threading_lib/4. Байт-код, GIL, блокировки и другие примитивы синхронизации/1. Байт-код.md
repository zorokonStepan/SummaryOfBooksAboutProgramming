### БАЙТ-КОД
```
        Чтобы понять пределы многопоточности в Python, нам придется заглянуть за кулисы и разобраться в том, как 
    интерпретатор загружает и выполняет код.
    
        Сам байт-код является деталью реализации и хранится в файлах с расширением .pyc. Он представляет поведение 
    программы на самом низком уровне. Интерпретация такого сложного языка, как Python, – нетривиальная задача, поэтому 
    интерпретатор кеширует результат в виде последовательности простых операций.
```

```
        Функция dis.dis(func) выводит байт-код заданной функции в предположении, что она написана на Python, а не 
    является C-расширением. Например, функция sorted(...) написана на C, поэтому байт-кода у нее нет.
```

```
        Для демонстрации рассмотрим функцию и результат ее дизассемблирования, полученный с помощью вызова 
    dis.dis(increment). Дизассемблер показывает номер строки в исходном файле, смещение байт-кода команды от начала 
    функции, имя команды и ее параметры – значения и в скобках соответствующие переменные или константы в Python-коде.
    
    Простая функция, увеличивающая глобальную переменную на 1
    
        num = 0
        def increment():
            global num
            num += 1 # 5 0 LOAD_GLOBAL 0 (num)
            
            
                # 2 LOAD_CONST    1 (1)
                # 4 INPLACE_ADD
                # 6 STORE_GLOBAL  0 (num)
    return None # 10 8 LOAD_CONST 0 (None)
                # 10 RETURN_VALUE
                
        Строка num += 1 выглядит как атомарная операция1, но байт-код показывает, что для ее выполнения интерпретатору 
    нужно четыре операции. Нам все равно, что это за операции, важно лишь, что нельзя доверять интуиции в вопросе о том, 
    какие операции атомарны, а какие – нет.
    
        Если бы мы выполнили эту функцию 100 раз, то в переменной num оказалось бы значение 100, что вполне логично. 
    Но если бы эта функция выполнялась в двух потоках, то нет никакой гарантии, что результат был бы равен 100. 
    Правильный результат получился бы, только если второй поток ни разу не выполнил команду байт-кода LOAD_GLOBAL в то 
    время, как первый был занят командами LOAD_CONST, IN_PLACE_ADD или STORE_GLOBAL. Python этого не гарантирует, 
    поэтому показанный код не является потокобезопасным.
```
