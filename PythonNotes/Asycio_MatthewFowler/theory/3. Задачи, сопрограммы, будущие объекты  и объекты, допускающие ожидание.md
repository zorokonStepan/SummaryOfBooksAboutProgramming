### Введение в будущие объекты
```
    Объект future в Python содержит одно значение, которое мы ожидаем получить в будущем, но пока еще, 
    возможно, не получили. 
    
    Обычно в момент создания future не обертывает никакого значения, потому что его еще не существует. 
    Объект в таком состоянии называется неполным, неразрешенным или просто неготовым. И только получив 
    результат, мы можем установить значение объекта future, в результате чего он становится полным и из 
    него можно извлечь результат. 
    
    Те, кто знаком с JavaScript, легко увидят аналогию с обещаниями (promise). 
    В Java похожая концепция называется дополняемыми будущими объектами (completable future).
```

### Связь между будущими объектами, задачами и сопрограммами
```
    Между задачами и будущими объектами существует тесная связь. На самом деле task напрямую наследует future. 
    Можно считать, что объект future представляет значение, которое появится только в будущем. 
    А task является комбинацией сопрограммы и future. 
    
    Создавая задачу, мы создаем пустой объект future и запускаем сопрограмму.
    А когда сопрограмма завершится с результатом или вследствие исключения, мы записываем этот результат или 
    объект-исключение во future.
    
    А существует ли аналогичная связь между задачами и сопрограммами? 
    Ведь все эти типы можно использовать в выражениях await.
    
    Связующим звеном между ними является абстрактный базовый класс Awaitable. 
    В нем определен единственный абстрактный метод __await__. 
    
    Любой объект, который реализует метод __await__, можно использовать в выражении await. 
    Сопрограммы, как и будущие объекты, наследуют Awaitable напрямую. 
    Задачи же расширяют будущие объекты.
    
    Awaitable -> Coroutine
    Awaitable -> Future -> Task
```











