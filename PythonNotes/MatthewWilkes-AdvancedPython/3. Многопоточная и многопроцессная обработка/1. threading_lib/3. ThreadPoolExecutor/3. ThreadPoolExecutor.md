```
        В стандартной библиотеке имеется вспомогательный класс concurrent.futures.ThreadPoolExecutor, который управляет 
    используемыми потоками, позволяя программисту ограничить число одновременно выполняемых потоков.
    
        Поток, печатающий сообщение «Hello world», можно эквивалентно запустить с помощью ThreadPoolExecutor:
        
                    from concurrent.futures import ThreadPoolExecutor
                    
                    def hello_world():
                        print("Hello world!")
                    
                    with ThreadPoolExecutor() as pool:
                        pool.submit(hello_world)
        
        Поскольку исполнителю не передан аргумент max_threads, Python берет столько потоков, сколько процессорных ядер 
    имеется на компьютере, исполняющем программу.    
        
        Внутри контекстного менеджера программа отправляет вызовы функций пулу потоков. Функцию pool.submit(...) можно 
    вызывать сколько угодно раз для планирования дополнительных задач. Ее результатом является объект Future, 
    представляющий задачу. Такие «будущие» объекты хорошо знакомы программистам на современном JavaScript; 
    они представляют значение (или ошибку), которое будет получено в будущем. 
    
        Метод result() представляет значение, возвращенное функцией, переданной пулу. Если функция возбудила 
    исключение, то это же исключение будет возбуждено при вызове result().
    
                    from concurrent.futures import ThreadPoolExecutor
    
    
                    def calculate():
                        return 2**16

                    with ThreadPoolExecutor() as pool:
                        task = pool.submit(calculate)
                        print(task.result())  # 65536
                        
        Если не вызвать метод result() будущего объекта, то исключения, которые могла возбудить задача, не дойдут до 
    главного потока. Это может затруднить отладку, поэтому лучше всегда обращаться к результату, даже если вы не 
    собираетесь присваивать его переменной.      
    
        Если метод result() вызван внутри блока with, то выполнение блокируется, пока соответствующая задача не будет 
    завершена. По выходе из блока with выполнение блокируется до тех пор, пока не завершатся все запланированные задачи, 
    поэтому обращение к методу result() после блока with всегда возвращает управление немедленно.              
```