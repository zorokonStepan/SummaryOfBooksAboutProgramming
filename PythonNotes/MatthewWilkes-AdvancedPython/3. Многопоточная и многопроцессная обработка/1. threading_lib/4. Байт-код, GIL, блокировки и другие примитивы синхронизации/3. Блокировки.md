### Блокировки
```
        Если требуется разделить состояние между потоками, то необходимо вручную защищать его с помощью блокировок. 
    Блокировки – это объекты, которые не дают коду выполняться одновременно с другим кодом, который мог бы нарушить 
    работу. Если два конкурентных потока одновременно попытаются захватить блокировку, то успех будет сопутствовать 
    только одному. Все прочие потоки должны будут ждать, когда поток, владеющий блокировкой, освободит ее. Это возможно, 
    потому что блокировки реализованы на языке C, а это означает, что единицей их исполнения является машинная команда, 
    поэтому ожидание блокировки и ее захват – атомарные операции.
    
        Код, защищенный блокировкой, может быть прерван, но даже в этот период никакой конфликтующий код не будет 
    выполнен. Да, поток может прерваться, когда удерживает блокировку. Но если прервавший его поток попытается захватить 
    ту же самую блокировку, то у него ничего не получится, а его выполнение будет приостановлено. Если в программе 
    работает всего два потока, то это означает, что управление будет возвращено первому. Если потоков больше, то сначала 
    управление может быть передано другим потокам, но и они точно так же не смогут получить удерживаемую первым потоком 
    блокировку.
    
    # Функция инкремента с блокировкой
    import threading
    
    numlock = threading.Lock()
    num = 0
    def increment():
        global num
        with numlock:
            num += 1
        return None
        
        В этом варианте функции для защиты чтения и записи num используется блокировка numlock. Контекстный менеджер 
    захватывает блокировку перед тем как передать управление блоку контекстного менеджера, и освобождает ее, прежде чем 
    выполнить первую строку после блока контекстного менеджера. Накладные расходы здесь присутствуют, но они минимальны, 
    зато гарантируется, что код будет работать правильно вне зависимости от установленных пользователем настроек или 
    версии интерпретатора Python.
    
        Этот код дает правильный результат при любом интервале между переключениями потоков, поскольку все четыре 
    команды байт-кода, в которые транслируется предложение num += 1, гарантированно выполняются как один блок. До и 
    после такого блока из четырех команд вставлены дополнительные команды управления блокировкой.
```

### Взаимоблокировки
```
        Трудность же состоит в том, чтобы не забыть поставить блокировки и избежать конфликта между ними. Если 
    определены и одновременно используются две блокировки, то может возникнуть так называемая взаимоблокировки.
    
        Оптимально было бы гарантировать, что блокировки никогда не удерживаются одновременно. Тогда они полностью 
    независимы, поэтому никакого риска взаимоблокировки не возникает. При такой схеме потокам не придется захватывать 
    новую блокировку до тех пор, пока они не освободят предыдущую.  
```
