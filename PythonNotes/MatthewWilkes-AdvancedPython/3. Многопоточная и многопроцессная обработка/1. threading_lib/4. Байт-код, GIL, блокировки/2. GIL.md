### GIL
```
        В CPython имеется так называемая глобальная блокировка интерпретатора (Global Interpreter Lock – GIL), 
    призванная упростить обеспечение потокобезопасности.
    
        Эта блокировка означает, что в каждый момент времени исполнять Python-код может только один поток. Однако этого 
    недостаточно для решения нашей проблемы, потому что уровень гранулярности GIL – команда байт-кода, а это значит, что 
    хотя никакие две команды не могут выполняться одновременно, интерпретатор все равно может переключаться между путями 
    выполнения, что приводит к перекрытию. 
    
        Утверждение о том, что никакие две команды байт-кода не могут исполняться одновременно, не совсем верно.
    Команды байт-кода гораздо проще предложений Python, что позволяет интерпретатору делать заключения о том, какие 
    действия он выполняет в данный момент. Поэтому он может позволить нескольким потокам работать, если это безопасно, 
    например во время установления сетевого подключения или ожидания чтения данных из файла.
    
        Точнее, не все, что делает интерпретатор Python, требует захвата GIL. 
        
        Можно захватить GIL на все время от начала до конца исполнения команды байт-кода, но можно и освобождать в 
    промежутке. Ожидание появления данных в сокете – одна из вещей, которые можно делать, не захватывая GIL. Если 
    во время выполнения команды происходит операция ввода-вывода, то GIL можно освободить, и тогда интерпретатор может 
    одновременно выполнять любой код, не требующий захвата GIL, при условии что он находится в другом потоке. После того 
    как операция ввода-вывода завершится, поток должен ждать, когда сможет снова захватить GIL, удерживаемый другим 
    потоком, после чего может возобновить выполнение.    
    
        В ситуациях, когда код никогда не должен ждать завершения операции ввода-вывода, Python прерывает потоки через 
    некоторые промежутки времени, чтобы планирование потоков было справедливым.
    
        По умолчанию это происходит раз приблизительно в 0.005 секунды – достаточно долго, чтобы на моем компьютере наш 
    пример работал, как ожидается. Но если бы мы попросили интерпретатор переключать потоки чаще, вызвав функцию 
    sys.setswitchinterval(...), то начались бы ошибки.
    
    
    if __name__ == "__main__":
        import concurrent.futures
        import sys
        
        
        for si in [0.005, 0.0000005, 0.0000000005]:
            sys.setswitchinterval(si)
            results = []
            
            for attempt in range(100):
                with concurrent.futures.ThreadPoolExecutor(max_workers=2) as pool:
                    for i in range(100):
                        pool.submit(increment)
                
                results.append(num)
                num = 0
                
            correct = [a for a in results if a == 100]
            pct = len(correct) / len(results)
            print(f"{pct:.1%} правильно при sys.setswitchinterval({si:.10f})")
            
    На моем компьютере при прогоне этой программы было напечатано
    100.0% правильно при sys.setswitchinterval(0.0050000000)
    71.0% правильно  при sys.setswitchinterval(0.0000005000)
    84.0% правильно  при sys.setswitchinterval(0.0000000005)
```
