# Конкурентность, параллелизм и многозадачность

## Конкурентность
```
    Задачи выполняются на одном процессоре, в одном потоке. Получаются задачи конкурируют за ресурсы.
```

## Параллелизм
```
    Задачи выполняются в одно и то же время в разных потоках. Если один процессор допускает несколько потоков
    выполнения, то задачи в параллельном режиме могут выполняться на одном процессоре.
```

## Многозадачность
```
    Выполнение одним "работником" задач. 
```

### Вытесняющая многозадачность
```
    В этой модели мы позволяем операционной системе решить, как переключаться между выполняемыми задачами
    с помощью процедуры КВАНТОВАНИЯ ВРЕМЕНИ. 
    Когда операционная система переключает задачи, мы говорим, что имеет место вытеснение. 
    Как устроен этот механизм, зависит от операционной системы. 
    Обычно для этого используется либо несколько потоков, либо несколько процессов.
```

### Кооперативная многозадачность
```
    В этой модели мы не полагаемся для переключения между задачами на операционную систему,
    а явно определяем в коде приложения точки, где можно уступить управление другой задаче. 
    Исполняемые задачи кооперируются, т. е. говорят приложению: «Я сейчас на время 
    приостановлюсь, а ты можешь пока выполнять другие задачи».
```

###  Преимущества кооперативной многозадачности перед вытесняющей
```
    1. ПОТРЕБЛЯЕТ МЕНЬШЕ РЕСУРСОВ
       Когда операционной системе нужно переключиться между потоками или процессами, мы говорим, что имеет 
       место контекстное переключение. Это трудоемкая операция, потому что операционная система должна 
       сохранить всю информацию о работающем процессе или потоке, чтобы потом его можно было возобновить.
    2. ГРАНУЛЯРНОСТЬ
       Операционная система приостанавливает поток или процесс в соответствии со своим алгоритмом планирования,
       но выбранный для этого момент не всегда оптимален. В случае кооперативной многозадачности мы явно 
       помечаем точки, в которых приостановить задачу наиболее выгодно. Это дает выигрыш в эффективности,
       потому что мы переключаем задачи именно в тот момент, когда это нужно. 
```

Библиотека asyncio исполняет сопрограммы асинхронно, пользуясь моделью конкурентности, 
получившей название ОДНОПОТОЧНЫЙ ЦИКЛ СОБЫТИЙ.

В asyncio для организации конкурентности используется кооперативная многозадачность

---

# Процессы, потоки, многопоточность и многопроцессность

## Процесс
``` 
    Процессом называется работающее приложение, которому выделена область памяти, недоступная другим приложениям.
      
    Пример создания Python-процесса – запуск простого приложения «hello world» или ввод слова python в командной 
    строке для запуска цикла REPL (цикл чтения–вычисления–печати).
    
    На одной машине может работать несколько процессов. 
    Если машина оснащена процессором с несколькими ядрами, то несколько процессов могут работать одновременно. 
    Если процессор имеет только одно ядро, то можно выполнять несколько приложений конкурентно, но уже с 
    применением квантования времени. При использовании квантования операционная система будет автоматически
    вытеснять работающий процесс по истечении некоторого промежутка времени и передавать процессор другому процессу. 
    Алгоритмы, определяющие, в какой момент переключать процессы, зависят от операционной системы.
```

## Поток
```
    Потоки можно представлять себе как облегченные процессы. 
    Кроме того, это наименьшая единица выполнения, которая может управляться операционной системой. 
    
    У  потоков нет своей памяти, они пользуются памятью создавшего их процесса. 
    Потоки ассоциированы с процессом, создавшим их. 
    
    С каждым процессом всегда ассоциирован по меньшей мере один поток, обычно называемый ГЛАВНЫМ.     
    Процесс может создавать дополнительные потоки, которые обычно называются РАБОЧИМИ ИЛИ ФОНОВЫМИ. 
    Эти потоки могут конкурентно выполнять другую работу наряду с главным потоком. 
    
    Потоки, как и процессы, могут работать параллельно на многоядерном процессе, и операционная система может 
    переключаться между ними с помощью квантования времени. 
    
    Обычное Python-приложение создает процесс и главный поток, который отвечает за его выполнение.
```
---
```
      Многопоточные приложения – обычный способ реализации конкурентности во многих языках программирования. 
    Но в Python есть несколько препятствий на пути организации конкурентности с помощью потоков. 
    
      Многопоточность полезна только для задач, ограниченных производительностью ввода-вывода, потому что нам мешает 
    глобальная блокировка интерпретатора. 
    
      Многопоточность не единственный способ добиться конкурентности. Можно вместо потоков создать несколько 
    конкурентных процессов, это называется МНОГОПРОЦЕССНОСТЬЮ. В таком случае родительский процесс создает один
    или более дочерних процессов, которыми управляет, а затем распределяет между ними работу.
    
      В Python для этой цели имеется модуль multiprocessing. Его API похож на API модуля threading. 
    Сначала создается процесс, при этом передается функция target. Затем вызывается метод start, 
    чтобы начать выполнение процесса, и в конце – метод join, чтобы дождаться его завершения.   
```

Многопроцессность обычно предпочтительна, когда имеется счетная задача.

У каждого процесса своя память и свой GIL