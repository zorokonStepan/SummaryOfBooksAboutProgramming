### Глобальная блокировка интерпретатора (global interpreter lock – GIL) – 
```    
    Говоря кратко, GIL не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени. 
    
    Это означает, что, даже если имеется несколько потоков на многоядерной машине, интерпретатор сможет 
    в каждый момент исполнять только один поток, содержащий написанный на Python код. 
```

Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что 
у каждого Python-процесса своя собственная GIL

### Для чего же нужна GIL?
```
    Ответ кроется в том, как CPython управляет памятью. 
    В CPython память управляется в основном с помощью подсчета ссылок.
    То есть для каждого объекта Python, например целого числа, словаря или списка, подсчитывается, сколько объектов 
    в данный момент используют его. Когда объект перестает быть нужным кому-то, счетчик ссылок на него уменьшается, 
    а когда кто-то новый обращается к нему, счетчик ссылок увеличивается. Если счетчик ссылок обратился в нуль, значит, 
    на объект никто не ссылается, поэтому его можно удалить из памяти.
    
    Конфликт потоков возникает из-за того, что интерпретатор CPython НЕ ЯВЛЯЕТСЯ ПОТОКОБЕЗОПАСНЫМ. 
    Это означает, что если два или более потоков модифицируют разделяемую переменную, то ее конечное состояние может 
    оказаться неожиданным, поскольку зависит от порядка доступа к  переменной со стороны потоков. 
    
    Эта ситуация называется СОСТОЯНИЕМ ГОНКИ. 
    
    Состояния гонки могут возникать, когда два потока одновременно обращаются к одному объекту Python
```

### Освобождается ли когда-нибудь GIL?
```
    1. Глобальная блокировка интерпретатора освобождается на время выполнения операций ввода-вывода.
    
        - Это позволяет использовать потоки для конкурентного выполнения ввода-вывода, но не для выполнения 
          счетного кода, написанного на Python (есть исключения, когда GIL все же освобождается на время 
          выполнения счетных задач). 

```

### почему же GIL освобождается при вводе-выводе, но не освобождается для счетных задач?
```
    Все дело в системных вызовах, которые выполняются за кулисами. 
    
    В  случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python.
    Это позволяет освободить GIL, потому что код операционной системы не взаимодействует напрямую с объектами Python. 
    GIL захватывается снова, только когда полученные данные переносятся в объект Python. Стало быть, на уровне ОС 
    операции ввода-вывода выполняются конкурентно. 
    
    Эта модель обеспечивает конкурентность, но не параллелизм. В других языках, например Java или C++, на 
    многоядерных машинах можно организовать истинный параллелизм, потому что никакой GIL нет и код может
    выполняться строго одновременно. Но в Python лучшее, на что можно рассчитывать, – конкурентность 
    операций ввода-вывода, поскольку в любой момент может выполняться только один кусок написанного на Python кода.
```

В Python многопоточность может быть реализована только конкурентно.

### Аsyncio и GIL
```
    В asyncio используется тот факт, что операции ввода-вывода освобождают GIL, что позволяет реализовать 
    конкурентность даже в одном потоке. При работе с asyncio мы создаем объекты сопрограмм. 
    
    Сопрограмму можно представлять себе как облегченный поток. Точно так же, как может быть несколько потоков, 
    работающих одновременно и исполняющих разные операции ввода-вывода, так может существовать много сопрограмм, 
    работающих бок о бок. Ожидая завершения сопрограмм, занимающихся вводом-выводом, мы можем выполнять другой 
    Python-код, получая таким образом конкурентность. 
    
    Важно отметить, что asyncio не обходит GIL, мы по-прежнему ограничены ей. 
    Если имеется счетная задача, то для ее конкурентного выполнения все равно нужно заводить отдельный процесс 
    (и в asyncio есть для этого средства), иначе производительность снизится. 
```

### Что такое сокет?
```
    Сокет – это низкоуровневая абстракция отправки и получения данных по сети. 
    
    Именно с  ее помощью производится обмен данными между клиентами и  серверами. 
    Сокеты поддерживают две основные операции: отправку и получение байтов. 
    Мы записываем байты в сокет, затем они передаются по адресу назначения, чаще всего на какой-то сервер. 
    Отправив байты, мы ждем, пока сервер пришлет ответ в наш сокет. Когда байты окажутся в сокете, мы сможем прочитать 
    результат.
    
    По умолчанию сокеты блокирующие. 
    
    Это значит, что на все время ожидания ответа от сервера приложение приостанавливается или блокируется. 
    Следовательно, оно не может ничего делать, пока не придут данные от сервера или произойдет ошибка или случится 
    тайм-аут.
    
    На уровне операционной системы эта блокировка ни к чему. Сокеты могут работать в неблокирующем режиме, когда мы 
    просто начинаем операцию чтения или записи и забываем о ней, а сами занимаемся другими делами. 
    Но позже операционная система уведомляет нас о том, что байты получены, и в этот момент мы можем уделить 
    им внимание. Это позволяет приложению не ждать прихода байтов, а делать что-то полезное. 
    
    Для реализации такой схемы применяются различные системы уведомления с помощью событий, разные в разных ОС. 
    Библиотека asyncio абстрагирует различия между системами уведомления. 
```

### Как работает цикл событий
```
    Цикл событий – сердце любого приложения asyncio. 
    
    Этот паттерн проектирования встречается во многих системах и был придуман уже довольно давно. 
    Используя в браузере JavaScript для отправки асинхронного запроса, вы создаете задачу, управляемую циклом событий. 
    В GUI-приложениях Windows за кулисами используются так называемые циклы обработки сообщений; это основной механизм 
    обработки таких событий, как нажатие клавиш, он позволяет одновременно отрисовывать интерфейс и реагировать на 
    действия пользователя. 
    
    По сути своей цикл событий очень прост. Мы создаем очередь, в которой хранится список событий или сообщений, 
    а затем входим в бесконечный цикл, где обрабатываем сообщения по мере их поступления. 
```

```
    В asyncio цикл событий управляет очередью задач, а не сообщений. 
    
    Задача – это обертка вокруг сопрограммы. 
    
    Сопрограмма может приостановить выполнение, встретив операцию ввода-вывода, и дать циклу событий возможность 
    выполнить другие задачи, которые не ждут завершения ввода-вывода.
    
    Создавая цикл событий, мы создаем пустую очередь задач. Затем добавляем в  эту очередь задачи для выполнения. 
    На каждой итерации цикла проверяется, есть ли в очереди готовая задача, и если да, то она выполняется, пока не 
    встретит операцию ввода-вывода. В этот момент задача приостанавливается, и мы просим операционную систему наблюдать
    за ее сокетами. А сами тем временем переходим к следующей готовой задаче. На каждой итерации проверяется, 
    завершилась ли какая-нибудь операция ввода-вывода; если да, то ожидавшие ее завершения задачи пробуждаются и им 
    предоставляется возможность продолжить работу. 
```



























